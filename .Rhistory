#ACP Centrée réduite (Toutes les variables ont la même importance)
Tt_sH_Rr <- t(DataBio[c(1: 36)])
DataBioCR <- scale(Tt_sH_Rr, center=F, scale=F)
traitements2 <- rep(c(rep("T1", 6), rep("T2", 6), rep("T3", 6)), 2)
heures2 <- rep(c(rep("1H", 1), rep("2H", 1), rep("3H", 1),rep("4H", 1), rep("5H", 1), rep("6H", 1)), 6)
# On fait la transposée pour avoir : les Tt_sH_Rr décrits par les gènes (J'avour je suis pas sûr à 100% pour ce passage. Sinon on peut enlever la transposée)
ACP_DataBio_reduite <- PCA(Tt_sH_Rr,  scale.unit = F, graph = F)
ACP_DataBio_reduite$eig
g1 = fviz_eig(ACP_DataBio_reduite,addlabels = TRUE, ylim = c(0, 100), main = "Valeurs propres")
# Projection des individus
g2 = fviz_pca_ind(ACP_DataBio_reduite, geom = c("point"),col.ind = "cos2", habillage = as.factor(traitements2), repel = TRUE, title = "Projection des individus (Tt_sH_Rr)")
g3 = fviz_pca_ind(ACP_DataBio_reduite, geom = c("point"),col.ind = "cos2", habillage = as.factor(heures2), repel = TRUE, title = "Projection des individus (Tt_sH_Rr)")
g4 = fviz_pca_var(ACP_DataBio_reduite,geom=c("point"),habillage=as.factor(DataBio$ExpT1))
g5 = fviz_pca_var(ACP_DataBio_reduite,geom=c("point"),habillage=as.factor(DataBio$ExpT2))
g6 = fviz_pca_var(ACP_DataBio_reduite,geom=c("point"),habillage=as.factor(DataBio$ExpT3))
grid.arrange(g1, g2, g3, nrow=2)
grid.arrange(g4, g5, g6, nrow=2)
# A présent, on passe sur l'ACP Centrée. Pour cela, on commence par centrer notre jeu de données.
#ACP Centrée réduite (Toutes les variables ont la même importance)
Tt_sH_Rr <- t(DataBio[c(1: 36)])
DataBioCR <- scale(Tt_sH_Rr, center=F, scale=F)
traitements2 <- rep(c(rep("T1", 6), rep("T2", 6), rep("T3", 6)), 2)
heures2 <- rep(c(rep("1H", 1), rep("2H", 1), rep("3H", 1),rep("4H", 1), rep("5H", 1), rep("6H", 1)), 6)
# On fait la transposée pour avoir : les Tt_sH_Rr décrits par les gènes (J'avour je suis pas sûr à 100% pour ce passage. Sinon on peut enlever la transposée)
ACP_DataBio_reduite <- PCA(Tt_sH_Rr,  scale.unit = F, graph = F)
#ACP_DataBio_reduite$eig
g1 = fviz_eig(ACP_DataBio_reduite,addlabels = TRUE, ylim = c(0, 100), main = "Valeurs propres")
# Projection des individus
g2 = fviz_pca_ind(ACP_DataBio_reduite, geom = c("point"),col.ind = "cos2", habillage = as.factor(traitements2), repel = TRUE, title = "Projection des individus (Tt_sH_Rr)")
g3 = fviz_pca_ind(ACP_DataBio_reduite, geom = c("point"),col.ind = "cos2", habillage = as.factor(heures2), repel = TRUE, title = "Projection des individus (Tt_sH_Rr)")
g4 = fviz_pca_var(ACP_DataBio_reduite,geom=c("point"),habillage=as.factor(DataBio$ExpT1))
g5 = fviz_pca_var(ACP_DataBio_reduite,geom=c("point"),habillage=as.factor(DataBio$ExpT2))
g6 = fviz_pca_var(ACP_DataBio_reduite,geom=c("point"),habillage=as.factor(DataBio$ExpT3))
grid.arrange(g1, g2, g3, nrow=2)
grid.arrange(g4, g5, g6, nrow=2)
# A présent, on passe sur l'ACP Centrée. Pour cela, on commence par centrer notre jeu de données.
#ACP Centrée réduite (Toutes les variables ont la même importance)
Tt_sH_Rr <- t(DataBio[c(1: 36)])
DataBioCR <- scale(Tt_sH_Rr, center=F, scale=F)
traitements2 <- rep(c(rep("T1", 6), rep("T2", 6), rep("T3", 6)), 2)
heures2 <- rep(c(rep("1H", 1), rep("2H", 1), rep("3H", 1),rep("4H", 1), rep("5H", 1), rep("6H", 1)), 6)
# On fait la transposée pour avoir : les Tt_sH_Rr décrits par les gènes (J'avour je suis pas sûr à 100% pour ce passage. Sinon on peut enlever la transposée)
ACP_DataBio_reduite <- PCA(Tt_sH_Rr,  scale.unit = F, graph = F)
#ACP_DataBio_reduite$eig
g1 = fviz_eig(ACP_DataBio_reduite,addlabels = TRUE, ylim = c(0, 100), main = "Valeurs propres")
# Projection des individus
g2 = fviz_pca_ind(ACP_DataBio_reduite, geom = c("point"),col.ind = "cos2", habillage = as.factor(traitements2), repel = TRUE, title = "Projection des individus (Tt_sH_Rr) selon les traitement")
g3 = fviz_pca_ind(ACP_DataBio_reduite, geom = c("point"),col.ind = "cos2", habillage = as.factor(heures2), repel = TRUE, title = "Projection des individus (Tt_sH_Rr) selon les heures")
g4 = fviz_pca_var(ACP_DataBio_reduite,geom=c("point"),habillage=as.factor(DataBio$ExpT1), title = "Projection des variable selon l'expression des gènes du traitement 1")
g5 = fviz_pca_var(ACP_DataBio_reduite,geom=c("point"),habillage=as.factor(DataBio$ExpT2), title = "Projection des variable selon l'expression des gènes du traitement 2")
g6 = fviz_pca_var(ACP_DataBio_reduite,geom=c("point"),habillage=as.factor(DataBio$ExpT3), title = "Projection des variable selon l'expression des gènes du traitement 3")
grid.arrange(g1, g2, g3, nrow=2)
grid.arrange(g1, g2, g3, nrow=2)
grid.arrange(g1, g2, g3, nrow=2)
# Maintenant que l'ACP a été effectuée, on fait un clustering des classes à l'aide de la méthode K-means.
# Avant de débuter le clustering avec la méthode K-means, il faut déterminer le nombre de classes.
set.seed(123)
Kmax<-20
reskmeanscl<-matrix(0,nrow=nrow(DataBioCR),ncol=Kmax)
Iintra<-NULL
for (k in 1:Kmax){
resaux<-kmeans(DataBioCR,centers=k)
reskmeanscl[,k]<-resaux$cluster
Iintra<-c(Iintra,resaux$tot.withinss) # tot.withinss correspond à la somme des composantes au carré des éléments du cluster par cluster
}
df<-data.frame(K=1:20,Iintra=Iintra)
g1 = ggplot(df,aes(x=K,y=Iintra))+
geom_line()+
geom_point()+
xlab("Nombre de classes")+
ylab("Inertie intraclasse")
# Avec cette méthode, on dirait que le coude correspond lorsque le nombre de classes est de 2.
# On va alors utiliser 2 classes pour la méthode des K-means.
reskmeans<-kmeans(DataBioCR,centers = 3)
g2 = fviz_cluster(reskmeans,data=Tt_sH_Rr,
ellipse.type="norm",labelsize=8,
geom=c("point"))+ggtitle("")
#fviz_pca_ind(resacp,col.ind=as.factor(reskmeans$cluster),geom = c("point"),axes=c(1,2))
# A présent, on va essayer une autre méthode, la méthode hiérarchique.
# D'une part, on fait le calcul de la matrice de distances
dist_matrix <- dist(DataBioCR, method = "euclidean")
# Clustering hiérarchique avec la méthode de liaison "ward.D2", on peut aussi faire avec "single", "complete","average" ...
hc <- hclust(dist_matrix, method = "ward.D2")
# Afficher le dendrogramme
g3 = fviz_dend(hc,k=3,show_labels = FALSE,
rect = TRUE, rect_fill = TRUE,palette = "npg",
rect_border = "npg",
labels_track_height = 0.8)+ggtitle("")
grid.arrange(g1, g2, g3, nrow=2)
# A présent,on va essayer de construire la matrice DataExpMoy. C'est une matrice de taille G * 18. Le nombre de lignes correspond aux gènes et les colonnes correspondent aux moyennes de T1,T2,T3 pour chaque heure. On a alors :
# colonne 1 : moyenne(T1_1H_R1/2)
# colonne 2 : moyenne(T1_2H_R1/2)
# colonne 3 : moyenne(T1_3H_R1/2)
# colonne 4 : moyenne(T1_4H_R1/2)
# colonne 5 : moyenne(T1_5H_R1/2)
# colonne 6 : moyenne(T1_6H_R1/2)
# colonne 7 : moyenne(T2_1H_R1/2)
# colonne 8 : moyenne(T2_2H_R1/2)
# ...
# colonne 18 : moyenne(T3_6H_R1/2)
# On essaye de créer cette matrice :
cols_T1_R1 <- grep("^T1_.*_R1$", colnames(DataBio))  # T1 pour R1
cols_T1_R2 <- grep("^T1_.*_R2$", colnames(DataBio))  # T1 pour R2
cols_T2_R1 <- grep("^T2_.*_R1$", colnames(DataBio))  # T2 pour R1
cols_T2_R2 <- grep("^T2_.*_R2$", colnames(DataBio))  # T2 pour R2
cols_T3_R1 <- grep("^T3_.*_R1$", colnames(DataBio))  # T3 pour R1
cols_T3_R2 <- grep("^T3_.*_R2$", colnames(DataBio))  # T3 pour R2
# Moyenne pour T1
T1_means <- (DataBio[, cols_T1_R1] + DataBio[, cols_T1_R2]) / 2
# Moyenne pour T2
T2_means <- (DataBio[, cols_T2_R1] + DataBio[, cols_T2_R2]) / 2
# Moyenne pour T3
T3_means <- (DataBio[, cols_T3_R1] + DataBio[, cols_T3_R2]) / 2
MatriceDataExpMoy <- cbind(T1_means, T2_means, T3_means)
DataExpMoy <- as.data.frame(cbind(T1_means, T2_means, T3_means))
# Pour vérifier la taille
dim(DataExpMoy)  # Devrait être 542 × 18 (c'est bon)
# On utilise T1 /T2 /T3 pour Identifier les gènes particulièrement influents pour un traitement spécifique.
# Ajouter les colonnes ExpT1, ExpT2, ExpT3 pour un filtrage
DataExpMoy_full <- cbind(MatriceDataExpMoy, ExpT1 = DataBio$ExpT1, ExpT2 = DataBio$ExpT2, ExpT3 = DataBio$ExpT3)
# Moyenne des gènes surexprimés pour T1 à 6 heures
mean_sur_T1_6H <- mean(DataExpMoy_full[DataExpMoy_full$ExpT1 == "Sur", "T1_6H"])
print(mean_sur_T1_6H)
# On fait la ACP de ce nouveau jeu de données
DataExpMoyCR <- scale(DataExpMoy, center=F, scale=F)
# On fait la transposée pour avoir : les Tt_sH_Rr décrits par les gènes (J'avour je suis pas sûr à 100% pour ce passage. Sinon on peut enlever la transposée)
ACP_DataExpMoy_reduite <- PCA(DataExpMoyCR,  scale.unit = F, graph = F)
ACP_DataExpMoy_reduite$eig
g1 = fviz_eig(ACP_DataExpMoy_reduite,addlabels = TRUE, ylim = c(0, 100), main = "Valeurs propres")
# Projection des DataExpMoy
g2 = fviz_pca_ind(ACP_DataExpMoy_reduite, geom = c("point"),col.ind = "cos2", gradient.cols = c("blue", "red"), repel = TRUE, title = "Projection des DataExpMoy")
grid.arrange(g1, g2, nrow=2)
# Projection des variables
fviz_pca_var(ACP_DataExpMoy_reduite, col.var = "contrib",
gradient.cols = c("blue", "red"), repel = TRUE,
title = "Combinaison Traitement/Heure")
grid.arrange(g1, g2, nrow=2)
set.seed(123)
Kmax<-8
reskmeanscl<-matrix(0,nrow=nrow(ExpT),ncol=Kmax)
Iintra<-NULL
for (k in 1:Kmax){
afcm = MCA(ExpT,quali.sup=3,graph=F)
coeff = afcm$ind$coord
reseaux = kmeans(coeff,k)
reskmeanscl[,k]<-resaux$cluster
Iintra<-c(Iintra,resaux$tot.withinss) # tot.withinss correspond à la somme des composantes au carré des éléments du cluster par cluster
}
set.seed(123)
Kmax<-8
reskmeanscl<-matrix(0,nrow=nrow(ExpT),ncol=Kmax)
Iintra<-NULL
for (k in 1:Kmax){
afcm = MCA(ExpT,quali.sup=3,graph=F)
coeff = afcm$ind$coord
reseaux = kmeans(coeff,k)
reskmeanscl[,k-1]<-resaux$cluster
Iintra<-c(Iintra,resaux$tot.withinss) # tot.withinss correspond à la somme des composantes au carré des éléments du cluster par cluster
}
set.seed(123)
Kmax<-8
reskmeanscl<-matrix(0,nrow=nrow(ExpT),ncol=Kmax)
Iintra<-NULL
for (k in 2:Kmax){
afcm = MCA(ExpT,quali.sup=3,graph=F)
coeff = afcm$ind$coord
reseaux = kmeans(coeff,k)
reskmeanscl[,k]<-resaux$cluster
Iintra<-c(Iintra,resaux$tot.withinss) # tot.withinss correspond à la somme des composantes au carré des éléments du cluster par cluster
}
afcm = MCA(ExpT,quali.sup=3,graph=F)
fviz_mca_ind(X = afcm, geom=c("point"), habillage=1)
coeff = afcm$ind$coord
clkmeans = kmeans(coeff,2)
fviz_cluster(clkmeans, data=coeff,ellipse.type="norm",labelsize=8,geom=c("point"))+ggtitle("")
ClustExpT = clara(ExpT, 2, metric = c("euclidean"))
fviz_cluster(ClustExpT, data=ExpT, ellipse=TRUE, ellipse.type="convex", labelsize=8, geom=c("point")) + ggtitle("")
g1 = fviz_eig(ClustExpt,addlabels = TRUE, ylim = c(0, 100), main = "Valeurs propres")
g1 = fviz_eig(ClustExpT,addlabels = TRUE, ylim = c(0, 100), main = "Valeurs propres")
g1 = fviz_eig(clkmeans,addlabels = TRUE, ylim = c(0, 100), main = "Valeurs propres")
g1 = fviz_eig(coeff,addlabels = TRUE, ylim = c(0, 100), main = "Valeurs propres")
g1 = fviz_eig(ClustExpT,addlabels = TRUE, ylim = c(0, 100), main = "Valeurs propres")
g1 = fviz_eig(afcm,addlabels = TRUE, ylim = c(0, 100), main = "Valeurs propres")
fviz_eig(afcm,addlabels = TRUE, ylim = c(0, 100), main = "Valeurs propres")
grid.arrange(g1, g2, nrow=2)
# Afficher le dendrogramme
g3 = fviz_dend(hc_ExpMoy,k=6,show_labels = FALSE,
rect = TRUE, rect_fill = TRUE,palette = "npg",
rect_border = "npg",
labels_track_height = 0.8)+ggtitle("")
# Afficher le dendrogramme
fviz_dend(hc_ExpMoy,k=6,show_labels = FALSE,
rect = TRUE, rect_fill = TRUE,palette = "npg",
rect_border = "npg",
labels_track_height = 0.8)+ggtitle("")
set.seed(123)
afcm = MCA(ExpT,quali.sup=3,graph=F)
fviz_mca_ind(X = afcm, geom=c("point"), habillage=1)
coeff = afcm$ind$coord
clkmeans = kmeans(coeff,2)
fviz_cluster(clkmeans, data=coeff,ellipse.type="norm",labelsize=8,geom=c("point"))+ggtitle("")
ClustExpT = clara(ExpT, 2, metric = c("euclidean"))
fviz_cluster(ClustExpT, data=ExpT, ellipse=TRUE, ellipse.type="convex", labelsize=8, geom=c("point")) + ggtitle("")
fviz_eig(afcm,addlabels = TRUE, ylim = c(0, 100), main = "Valeurs propres")
set.seed(123)
afcm = MCA(ExpT,quali.sup=3,graph=F)
g1 = fviz_mca_ind(X = afcm, geom=c("point"), habillage=1)
g2 = fviz_mca_ind(X = afcm, geom=c("point"), habillage=1)
g3 = fviz_mca_ind(X = afcm, geom=c("point"), habillage=1)
coeff = afcm$ind$coord
clkmeans = kmeans(afcm,2)
set.seed(123)
afcm = MCA(ExpT,quali.sup=3,graph=F)
g1 = fviz_mca_ind(X = afcm, geom=c("point"), habillage=1)
g2 = fviz_mca_ind(X = afcm, geom=c("point"), habillage=1)
g3 = fviz_mca_ind(X = afcm, geom=c("point"), habillage=1)
coeff = afcm$ind$coord
clkmeans = kmeans(coeff,2)
fviz_cluster(afcm, data=coeff,ellipse.type="norm",labelsize=8,geom=c("point"))+ggtitle("")
set.seed(123)
afcm = MCA(ExpT,quali.sup=3,graph=F)
g1 = fviz_mca_ind(X = afcm, geom=c("point"), habillage=1)
g2 = fviz_mca_ind(X = afcm, geom=c("point"), habillage=1)
g3 = fviz_mca_ind(X = afcm, geom=c("point"), habillage=1)
coeff = afcm$ind$coord
clkmeans = kmeans(coeff,2)
fviz_cluster(clkmeans, data=coeff,ellipse.type="norm",labelsize=8,geom=c("point"))+ggtitle("")
ClustExpT = clara(ExpT, 2, metric = c("euclidean"))
fviz_cluster(ClustExpT, data=ExpT, ellipse=TRUE, ellipse.type="convex", labelsize=8, geom=c("point")) + ggtitle("")
fviz_eig(afcm, addlabels = TRUE, ylim = c(0, 100), main = "Valeurs propres")
grid.arrange(g1, g2, g3, nrow=2)
set.seed(123)
afcm = MCA(ExpT,quali.sup=3,graph=F)
g1 = fviz_mca_ind(X = afcm, geom=c("point"), habillage=1)
g2 = fviz_mca_ind(X = afcm, geom=c("point"), habillage=2)
g3 = fviz_mca_ind(X = afcm, geom=c("point"), habillage=3)
coeff = afcm$ind$coord
clkmeans = kmeans(coeff,2)
fviz_cluster(clkmeans, data=coeff,ellipse.type="norm",labelsize=8,geom=c("point"))+ggtitle("")
ClustExpT = clara(ExpT, 2, metric = c("euclidean"))
fviz_cluster(ClustExpT, data=ExpT, ellipse=TRUE, ellipse.type="convex", labelsize=8, geom=c("point")) + ggtitle("")
fviz_eig(afcm, addlabels = TRUE, ylim = c(0, 100), main = "Valeurs propres")
grid.arrange(g1, g2, g3, nrow=2)
set.seed(123)
afcm = MCA(ExpT,quali.sup=3,graph=F)
g1 = fviz_mca_ind(X = afcm, geom=c("point"), habillage=1)
g2 = fviz_mca_ind(X = afcm, geom=c("point"), habillage=2)
g3 = fviz_mca_ind(X = afcm, geom=c("point"), habillage=3)
coeff = afcm$ind$coord
clkmeans = kmeans(coeff,2)
fviz_cluster(clkmeans, data=coeff,ellipse.type="norm",labelsize=8,geom=c("point"))+ggtitle("")
ClustExpT = clara(ExpT, 2, metric = c("euclidean"))
fviz_cluster(ClustExpT, data=ExpT, ellipse=TRUE, ellipse.type="convex", labelsize=8, geom=c("point")) + ggtitle("")
fviz_eig(afcm, addlabels = TRUE, ylim = c(0, 100), main = "Valeurs propres")
fviz_mca(afcm)
grid.arrange(g1, g2, g3, nrow=2)
set.seed(123)
afcm = MCA(ExpT,quali.sup=3,graph=F)
g1 = fviz_mca_ind(X = afcm, geom=c("point"), habillage=1)
g2 = fviz_mca_ind(X = afcm, geom=c("point"), habillage=2)
g3 = fviz_mca_ind(X = afcm, geom=c("point"), habillage=3)
coeff = afcm$ind$coord
clkmeans = kmeans(coeff,2)
fviz_cluster(clkmeans, data=coeff,ellipse.type="norm",labelsize=8,geom=c("point"))+ggtitle("")
ClustExpT = clara(ExpT, 2, metric = c("euclidean"))
fviz_cluster(ClustExpT, data=ExpT, ellipse=TRUE, ellipse.type="convex", labelsize=8, geom=c("point")) + ggtitle("")
fviz_eig(afcm, addlabels = TRUE, ylim = c(0, 100), main = "Valeurs propres")
fviz_mca_ind(afcm)
grid.arrange(g1, g2, g3, nrow=2)
set.seed(123)
afcm = MCA(ExpT,quali.sup=3,graph=F)
g1 = fviz_mca_ind(X = afcm, geom=c("point"), habillage=1)
g2 = fviz_mca_ind(X = afcm, geom=c("point"), habillage=2)
g3 = fviz_mca_ind(X = afcm, geom=c("point"), habillage=3)
coeff = afcm$ind$coord
clkmeans = kmeans(coeff,2)
fviz_cluster(clkmeans, data=coeff,ellipse.type="norm",labelsize=8,geom=c("point"))+ggtitle("")
ClustExpT = clara(ExpT, 2, metric = c("euclidean"))
fviz_cluster(ClustExpT, data=ExpT, ellipse=TRUE, ellipse.type="convex", labelsize=8, geom=c("point")) + ggtitle("")
fviz_eig(afcm, addlabels = TRUE, ylim = c(0, 100), main = "Valeurs propres")
fviz_mca_var(afcm)
grid.arrange(g1, g2, g3, nrow=2)
set.seed(123)
afcm = MCA(ExpT,quali.sup=3,graph=F)
g1 = fviz_mca_ind(X = afcm, geom=c("point"), habillage=1)
g2 = fviz_mca_ind(X = afcm, geom=c("point"), habillage=2)
g3 = fviz_mca_ind(X = afcm, geom=c("point"), habillage=3)
coeff = afcm$ind$coord
clkmeans = kmeans(coeff,3)
fviz_cluster(clkmeans, data=coeff,ellipse.type="norm",labelsize=8,geom=c("point"))+ggtitle("")
ClustExpT = clara(ExpT, 2, metric = c("euclidean"))
fviz_cluster(ClustExpT, data=ExpT, ellipse=TRUE, ellipse.type="convex", labelsize=8, geom=c("point")) + ggtitle("")
fviz_eig(afcm, addlabels = TRUE, ylim = c(0, 100), main = "Valeurs propres")
grid.arrange(g1, g2, g3, nrow=2)
set.seed(123)
afcm = MCA(ExpT,quali.sup=3,graph=F)
g1 = fviz_mca_ind(X = afcm, geom=c("point"), habillage=1)
g2 = fviz_mca_ind(X = afcm, geom=c("point"), habillage=2)
g3 = fviz_mca_ind(X = afcm, geom=c("point"), habillage=3)
g4 = fviz_eig(afcm, addlabels = TRUE, ylim = c(0, 100), main = "Valeurs propres")
coeff = afcm$ind$coord
clkmeans = kmeans(coeff,3)
fviz_cluster(clkmeans, data=coeff,ellipse.type="norm",labelsize=8,geom=c("point"))+ggtitle("")
ClustExpT = clara(ExpT, 2, metric = c("euclidean"))
fviz_cluster(ClustExpT, data=ExpT, ellipse=TRUE, ellipse.type="convex", labelsize=8, geom=c("point")) + ggtitle("")
grid.arrange(g1, g2, g3, g4, nrow=2)
set.seed(123)
afcm = MCA(ExpT,quali.sup=3,graph=F)
g1 = fviz_mca_ind(X = afcm, geom=c("point"), habillage=1)
g2 = fviz_mca_ind(X = afcm, geom=c("point"), habillage=2)
g3 = fviz_mca_ind(X = afcm, geom=c("point"), habillage=3)
g4 = fviz_eig(afcm, addlabels = TRUE, ylim = c(0, 100), main = "Valeurs propres")
coeff = afcm$ind$coord
clkmeans = kmeans(coeff,2)
fviz_cluster(clkmeans, data=coeff,ellipse.type="norm",labelsize=8,geom=c("point"))+ggtitle("")
ClustExpT = clara(ExpT, 2, metric = c("euclidean"))
fviz_cluster(ClustExpT, data=ExpT, ellipse=TRUE, ellipse.type="convex", labelsize=8, geom=c("point")) + ggtitle("")
grid.arrange(g1, g2, g3, g4, nrow=2)
set.seed(123)
afcm = MCA(ExpT,quali.sup=3,graph=F)
g1 = fviz_mca_ind(X = afcm, geom=c("point"), axes=c(1,2), habillage=1)
g2 = fviz_mca_ind(X = afcm, geom=c("point"), axes=c(1,3), habillage=1)
g3 = fviz_mca_ind(X = afcm, geom=c("point"), axes=c(2,3), habillage=1)
g4 = fviz_eig(afcm, addlabels = TRUE, ylim = c(0, 100), main = "Valeurs propres")
coeff = afcm$ind$coord
clkmeans = kmeans(coeff,2)
fviz_cluster(clkmeans, data=coeff,ellipse.type="norm",labelsize=8,geom=c("point"))+ggtitle("")
ClustExpT = clara(ExpT, 2, metric = c("euclidean"))
fviz_cluster(ClustExpT, data=ExpT, ellipse=TRUE, ellipse.type="convex", labelsize=8, geom=c("point")) + ggtitle("")
grid.arrange(g1, g2, g3, g4, nrow=2)
set.seed(123)
afcm = MCA(ExpT,quali.sup=3,graph=F)
g1 = fviz_mca_ind(X = afcm, geom=c("point"), axes=c(1,2), habillage=1)
g2 = fviz_mca_ind(X = afcm, geom=c("point"), axes=c(1,3), habillage=1)
g3 = fviz_mca_ind(X = afcm, geom=c("point"), axes=c(2,3), habillage=1)
g4 = fviz_eig(afcm, addlabels = TRUE, ylim = c(0, 100), main = "Valeurs propres")
coeff = afcm$ind$coord
clkmeans = kmeans(coeff,2)
fviz_cluster(clkmeans, data=coeff,ellipse.type="norm",labelsize=8,geom=c("point"))+ggtitle("")
grid.arrange(g1, g2, g3, g4, nrow=2)
set.seed(123)
afcm = MCA(ExpT,quali.sup=3,graph=F)
g1 = fviz_mca_ind(X = afcm, geom=c("point"), axes=c(1,2), habillage=1)
g2 = fviz_mca_ind(X = afcm, geom=c("point"), axes=c(1,3), habillage=1)
g3 = fviz_mca_ind(X = afcm, geom=c("point"), axes=c(2,3), habillage=1)
g4 = fviz_eig(afcm, addlabels = TRUE, ylim = c(0, 100), main = "Valeurs propres")
ClustExpT = clara(ExpT, 2, metric = c("euclidean"))
fviz_cluster(ClustExpT, data=ExpT, ellipse=TRUE, ellipse.type="convex", labelsize=8, geom=c("point")) + ggtitle("")
grid.arrange(g1, g2, g3, g4, nrow=2)
grid.arrange(g1, g2, g3, g4, nrow=2)
afcm = MCA(ExpT,quali.sup=3,graph=F)
g1 = fviz_mca_ind(X = afcm, geom=c("point"), axes=c(1,2), habillage=1)
g2 = fviz_mca_ind(X = afcm, geom=c("point"), axes=c(1,2), habillage=2)
g3 = fviz_mca_ind(X = afcm, geom=c("point"), axes=c(1,2), habillage=3)
g4 = fviz_eig(afcm, addlabels = TRUE, ylim = c(0, 100), main = "Valeurs propres")
grid.arrange(g1, g2, g3, g4, nrow=2)
ClustExpT = clara(ExpT, 2, metric = c("euclidean"))
fviz_cluster(ClustExpT, data=ExpT, ellipse=TRUE, ellipse.type="convex", labelsize=8, geom=c("point")) + ggtitle("")
ClustExpT = clara(ExpT, 2, metric = c("euclidean"))
fviz_cluster(ClustExpT, data=ExpT, ellipse=TRUE, ellipse.type="convex", labelsize=8, geom=c("point")) + ggtitle("")
ClustExpT = pam(ExpT, 2, metric = c("euclidean"))
fviz_cluster(ClustExpT, data=ExpT, ellipse=TRUE, ellipse.type="convex", labelsize=8, geom=c("point")) + ggtitle("")
ClustExpT = pam(ExpT, 2, metric = c("euclidean"))
fviz_cluster(ClustExpT, data=ExpT, ellipse=TRUE, ellipse.type="t", labelsize=8, geom=c("point")) + ggtitle("")
ClustExpT = pam(ExpT, 2, metric = c("euclidean"))
fviz_cluster(ClustExpT, data=ExpT, ellipse=TRUE, ellipse.type="norm", labelsize=8, geom=c("point")) + ggtitle("")
help(fviz_cluster)
ClustExpT = pam(ExpT, 2, metric = c("euclidean"))
fviz_cluster(ClustExpT, data=ExpT, ellipse=TRUE, ellipse.type="confidence", labelsize=8, geom=c("point")) + ggtitle("")
ClustExpT = pam(ExpT, 2, metric = c("euclidean"))
fviz_cluster(ClustExpT, data=ExpT, ellipse=TRUE, ellipse.type="convex", labelsize=8, geom=c("point")) + ggtitle("")
grid.arrange(g1, g2, nrow=2)
# Maintenant que l'ACP a été effectuée, on fait un clustering des classes à l'aide de la méthode K-means.
# Avant de débuter le clustering avec la méthode K-means, il faut déterminer le nombre de classes.
set.seed(123)
Kmax<-15
reskmeanscl<-matrix(0,nrow=nrow(DataExpMoyCR),ncol=Kmax)
Iintra<-NULL
for (k in 2:Kmax){
resaux<-kmeans(DataExpMoyCR,centers=k)
reskmeanscl[,k]<-resaux$cluster
Iintra<-c(Iintra,resaux$tot.withinss) # tot.withinss correspond à la somme des composantes au carré des éléments du cluster par cluster
}
df<-data.frame(K=2:15,Iintra=Iintra)
g1 = ggplot(df,aes(x=K,y=Iintra))+
geom_line()+
geom_point()+
xlab("Nombre de classes")+
ylab("Inertie intraclasse")
# Avec cette méthode, on dirait que le coude correspond lorsque le nombre de classes est de 2.
# On va alors utiliser 2 classes pour la méthode des K-means.
ExpMoykmeans<-kmeans(DataExpMoyCR,centers = 6)
g2 = fviz_cluster(ExpMoykmeans,data=DataExpMoyCR,ellipse.type="norm",labelsize=8,geom=c("point"))+ggtitle("")
#fviz_pca_ind(resacp,col.ind=as.factor(ExpMoykmean$cluster),geom = c("point"),axes=c(1,2))
# A présent, on va essayer une autre méthode, la méthode hiérarchique.
# D'une part, on fait le calcul de la matrice de distances
dist_matrix_ExpMoy <- dist(DataExpMoyCR, method = "euclidean")
# Clustering hiérarchique avec la méthode de liaison "ward.D2", on peut aussi faire avec "single", "complete","average" ...
hc_ExpMoy <- hclust(dist_matrix_ExpMoy, method = "ward.D2")
grid.arrange(g1, g2, nrow=2)
clust<-paste("DataExpMoy",ExpMoykmeans$cluster,sep="")
Tab<-melt(table(clust,DataBio[,37]))
g1 <- ggplot(Tab,aes(y=value,axis1=clust,axis2=Var2))+
geom_alluvium(aes(fill=clust))+
geom_stratum(width = 1/12)+
geom_text(stat = "stratum", aes(label = after_stat(stratum)))+
scale_x_discrete(limits = c("DataExpMoy", "ExpT1"), expand = c(.05, .05))+
theme(legend.position = "none")
clust<-paste("DataExpMoy",ExpMoykmeans$cluster,sep="")
Tab<-melt(table(clust,DataBio[,38]))
g2 <- ggplot(Tab,aes(y=value,axis1=clust,axis2=Var2))+
geom_alluvium(aes(fill=clust))+
geom_stratum(width = 1/12)+
geom_text(stat = "stratum", aes(label = after_stat(stratum)))+
scale_x_discrete(limits = c("DataExpMoy", "ExpT2"), expand = c(.05, .05))+
theme(legend.position = "none")
clust<-paste("DataExpMoy",ExpMoykmeans$cluster,sep="")
Tab<-melt(table(clust,DataBio[,39]))
g3 <- ggplot(Tab,aes(y=value,axis1=clust,axis2=Var2))+
geom_alluvium(aes(fill=clust))+
geom_stratum(width = 1/12)+
geom_text(stat = "stratum", aes(label = after_stat(stratum)))+
scale_x_discrete(limits = c("DataExpMoy", "ExpT3"), expand = c(.05, .05))+
theme(legend.position = "none")
grid.arrange(g1,g2,g3,ncol=3)
#Alluvial Diagram
ClustExpT = pam(ExpT, 2, metric = c("euclidean"))
fviz_cluster(ClustExpT, data=ExpT, ellipse=TRUE, ellipse.type="convex", labelsize=8, geom=c("point")) + ggtitle("")
# A présent,on va essayer de construire la matrice DataExpMoy. C'est une matrice de taille G * 18. Le nombre de lignes correspond aux gènes et les colonnes correspondent aux moyennes de T1,T2,T3 pour chaque heure. On a alors :
# colonne 1 : moyenne(T1_1H_R1/2)
# colonne 2 : moyenne(T1_2H_R1/2)
# colonne 3 : moyenne(T1_3H_R1/2)
# colonne 4 : moyenne(T1_4H_R1/2)
# colonne 5 : moyenne(T1_5H_R1/2)
# colonne 6 : moyenne(T1_6H_R1/2)
# colonne 7 : moyenne(T2_1H_R1/2)
# colonne 8 : moyenne(T2_2H_R1/2)
# ...
# colonne 18 : moyenne(T3_6H_R1/2)
# On essaye de créer cette matrice :
cols_T1_R1 <- grep("^T1_.*_R1$", colnames(DataBio))  # T1 pour R1
cols_T1_R2 <- grep("^T1_.*_R2$", colnames(DataBio))  # T1 pour R2
cols_T2_R1 <- grep("^T2_.*_R1$", colnames(DataBio))  # T2 pour R1
cols_T2_R2 <- grep("^T2_.*_R2$", colnames(DataBio))  # T2 pour R2
cols_T3_R1 <- grep("^T3_.*_R1$", colnames(DataBio))  # T3 pour R1
cols_T3_R2 <- grep("^T3_.*_R2$", colnames(DataBio))  # T3 pour R2
# Moyenne pour T1
T1_means <- (DataBio[, cols_T1_R1] + DataBio[, cols_T1_R2]) / 2
# Moyenne pour T2
T2_means <- (DataBio[, cols_T2_R1] + DataBio[, cols_T2_R2]) / 2
# Moyenne pour T3
T3_means <- (DataBio[, cols_T3_R1] + DataBio[, cols_T3_R2]) / 2
MatriceDataExpMoy <- cbind(T1_means, T2_means, T3_means)
DataExpMoy <- as.data.frame(cbind(T1_means, T2_means, T3_means))
# Pour vérifier la taille
dim(DataExpMoy)  # Devrait être 542 × 18 (c'est bon)
# On utilise T1 /T2 /T3 pour Identifier les gènes particulièrement influents pour un traitement spécifique.
# Ajouter les colonnes ExpT1, ExpT2, ExpT3 pour un filtrage
DataExpMoy_full <- cbind(MatriceDataExpMoy, ExpT1 = DataBio$ExpT1, ExpT2 = DataBio$ExpT2, ExpT3 = DataBio$ExpT3)
# Moyenne des gènes surexprimés pour T1 à 6 heures
mean_sur_T1_6H <- mean(DataExpMoy_full[DataExpMoy_full$ExpT1 == "Sur", "T1_6H"])
print(mean_sur_T1_6H)
# On fait la ACP de ce nouveau jeu de données
DataExpMoyCR <- scale(DataExpMoy, center=F, scale=F)
# On fait la transposée pour avoir : les Tt_sH_Rr décrits par les gènes (J'avour je suis pas sûr à 100% pour ce passage. Sinon on peut enlever la transposée)
ACP_DataExpMoy_reduite <- PCA(DataExpMoyCR,  scale.unit = F, graph = F)
ACP_DataExpMoy_reduite$eig
g1 = fviz_eig(ACP_DataExpMoy_reduite,addlabels = TRUE, ylim = c(0, 100), main = "Valeurs propres")
# Projection des DataExpMoy
g2 = fviz_pca_ind(ACP_DataExpMoy_reduite, geom = c("point"),col.ind = "cos2", gradient.cols = c("blue", "red"), repel = TRUE, title = "Projection des DataExpMoy")
# A présent,on va essayer de construire la matrice DataExpMoy. C'est une matrice de taille G * 18. Le nombre de lignes correspond aux gènes et les colonnes correspondent aux moyennes de T1,T2,T3 pour chaque heure. On a alors :
# colonne 1 : moyenne(T1_1H_R1/2)
# colonne 2 : moyenne(T1_2H_R1/2)
# colonne 3 : moyenne(T1_3H_R1/2)
# colonne 4 : moyenne(T1_4H_R1/2)
# colonne 5 : moyenne(T1_5H_R1/2)
# colonne 6 : moyenne(T1_6H_R1/2)
# colonne 7 : moyenne(T2_1H_R1/2)
# colonne 8 : moyenne(T2_2H_R1/2)
# ...
# colonne 18 : moyenne(T3_6H_R1/2)
# On essaye de créer cette matrice :
cols_T1_R1 <- grep("^T1_.*_R1$", colnames(DataBio))  # T1 pour R1
cols_T1_R2 <- grep("^T1_.*_R2$", colnames(DataBio))  # T1 pour R2
cols_T2_R1 <- grep("^T2_.*_R1$", colnames(DataBio))  # T2 pour R1
cols_T2_R2 <- grep("^T2_.*_R2$", colnames(DataBio))  # T2 pour R2
cols_T3_R1 <- grep("^T3_.*_R1$", colnames(DataBio))  # T3 pour R1
cols_T3_R2 <- grep("^T3_.*_R2$", colnames(DataBio))  # T3 pour R2
# Moyenne pour T1
T1_means <- (DataBio[, cols_T1_R1] + DataBio[, cols_T1_R2]) / 2
# Moyenne pour T2
T2_means <- (DataBio[, cols_T2_R1] + DataBio[, cols_T2_R2]) / 2
# Moyenne pour T3
T3_means <- (DataBio[, cols_T3_R1] + DataBio[, cols_T3_R2]) / 2
MatriceDataExpMoy <- cbind(T1_means, T2_means, T3_means)
DataExpMoy <- as.data.frame(cbind(T1_means, T2_means, T3_means))
# Pour vérifier la taille
#dim(DataExpMoy)  # Devrait être 542 × 18 (c'est bon)
# On utilise T1 /T2 /T3 pour Identifier les gènes particulièrement influents pour un traitement spécifique.
# Ajouter les colonnes ExpT1, ExpT2, ExpT3 pour un filtrage
DataExpMoy_full <- cbind(MatriceDataExpMoy, ExpT1 = DataBio$ExpT1, ExpT2 = DataBio$ExpT2, ExpT3 = DataBio$ExpT3)
# Moyenne des gènes surexprimés pour T1 à 6 heures
mean_sur_T1_6H <- mean(DataExpMoy_full[DataExpMoy_full$ExpT1 == "Sur", "T1_6H"])
#print(mean_sur_T1_6H)
# On fait la ACP de ce nouveau jeu de données
DataExpMoyCR <- scale(DataExpMoy, center=F, scale=F)
# On fait la transposée pour avoir : les Tt_sH_Rr décrits par les gènes (J'avour je suis pas sûr à 100% pour ce passage. Sinon on peut enlever la transposée)
ACP_DataExpMoy_reduite <- PCA(DataExpMoyCR,  scale.unit = F, graph = F)
ACP_DataExpMoy_reduite$eig
g1 = fviz_eig(ACP_DataExpMoy_reduite,addlabels = TRUE, ylim = c(0, 100), main = "Valeurs propres")
# Projection des DataExpMoy
g2 = fviz_pca_ind(ACP_DataExpMoy_reduite, geom = c("point"),col.ind = "cos2", gradient.cols = c("blue", "red"), repel = TRUE, title = "Projection des DataExpMoy")
