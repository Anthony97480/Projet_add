---
title: "Projet Analyse de Donnée"
author: "FERRERE HOAREAU Anthony et CALLIS Guilhem"
date: "`r Sys.Date()`"
output:
  pdf_document: default
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown
Chargement du jeux de donnée:
 Décrivez l’ensemble du jeu de données en précisant la nature des variables

```{r echo=F}
if (!require("ggplot2")) install.packages("ggplot2")
library("ggplot2")
DataBio = read.table("DataProjet3MIC-2425.txt", header=TRUE)
#affichage de la nature des variable du jeu de donnée
str(DataBio)
#mise en place des donnée qualitative
DataBio$ExpT1 = as.factor(DataBio$ExpT1)
DataBio$ExpT2 = as.factor(DataBio$ExpT2)
DataBio$ExpT3 = as.factor(DataBio$ExpT3)
print(summary(DataBio))
if (!require("corrplot")) install.packages("corrplot")
library(corrplot)
M_cor = cor(DataBio[1:36])
corrplot(M_cor, method="ellipse")
#on constate ici, une faible correlation de la part de T1 envers les autre traitement, et que le traitement 1 fonctionne particulièrement mal à la 6ème heure contrairement aux autres.
```
Faites une analyse uni-dimensionnelle et bi-dimensionnelle du jeu de données. Certaines variables sont-elles liées ? Une attention particulière sera portée sur le choix des représentations, et sur l’interprétation
des résultats présentés.
(Voilà ce que j'ai fais pour l'analyse uni-dimensionnelle. Je vais essayer de tout regrouper dans un seul graphe (je n'y arrive pas pour l'instant mais je vais continuer à essayer))
```{r echo=F}
if (!require("grid")) install.packages("grid")
library(grid)
if (!require("gridExtra")) install.packages("gridExtra")
library(gridExtra)
if (!require("lattice")) install.packages("lattice")
library(lattice)

# Faire une Analyse Unidimensionnelle du jeu de données.
# On commence par l'analyse des variables Qualitatives
# Effectif :
ExpT <- DataBio[(c(37,38,39))]

effT1 <- table(DataBio$ExpT1)
effT2 <- table(DataBio$ExpT2)
effT3 <- table(DataBio$ExpT3)

#print(effT1)
#print(effT2)
#print(effT3)

# Fréquence :
freqT1<-data.frame(effT1=c(effT1),Freq=c(effT1)/sum(effT1))
freqT2<-data.frame(effT2=c(effT2),Freq=c(effT2)/sum(effT2))
freqT3<-data.frame(effT3=c(effT3),Freq=c(effT3)/sum(effT3))

#print(freqT1)
#print(freqT2)
#print(freqT3)

# GGplot des variables qualitatives (Exp T1,T2,T3)
ggplot(DataBio, aes(x = ExpT1)) + geom_bar(fill = "blue")
ggplot(DataBio, aes(x = ExpT2)) + geom_bar(fill = "green")
ggplot(DataBio, aes(x = ExpT3)) + geom_bar(fill = "red")

# Pour les variables quantitatives
g1 <- boxplot(DataBio[c(1:18)], main = "Expression sous T1", col = "lightblue")
g2 <- boxplot(DataBio[c(19:36)], main = "Expression sous T1", col = "lightblue")

#grid.arrange(g1,g2,nrow=2) <-- Cette Ligne ne marche pas et je ne comprends pas pourquoi.
```
Interprétation des Résultats (analyse uni-dimensionnelle):
À la suite de cette analyse, plusieurs observations et conclusions peuvent être tirées sur les relations entre les variables : (on rappelle que T3 est une combinaison de T1 et T2, indiqué dans le sujet.)
En ce qui concerne l'analyse Uni-dimensionnelle sur les variables qualitatives, les fréquences des gènes classés comme surexprimés, sous-exprimés et non exprimés sont globalement similaires pour ExpT2 et ExpT3. Cela peut s'expliquer par le fait que T3 est une combinaison de T1 et T2, ce qui entraîne des distributions proches.
En revanche, ExpT1 se distingue clairement des deux autres, la majorité des gènes dans ExpT1 sont non exprimés, ce qui contraste avec les répartitions plus équilibrées observées pour ExpT2 et ExpT3. Cette observation suggère que le traitement T1 induit très peu de changements dans l'expression des gènes en réponse à un traitement.

Pour les variables quantitatives, on remarque plusieurs choses.

Menez une analyse en composantes principales où les Tt sH Rr sont les individus d´ecrits par les gènes. Premièrement, on remarque que les distributions des valeurs d’expression pour R1 et R2 sont remarquablement similaires. Cela indique une bonne reproductibilité biologique entre les réplicats.
La cohérence entre R1 et R2 valide la qualité des données et leur fiabilité pour les analyses ultérieures. Pour les traitements, T2 et T3 sont fortement liés, leurs médianes, leurs intervalles interquartiles sont très similaires.
Cela renforce l’idée que T3, étant une combinaison de T1 et T2, hérite principalement des caractéristiques de T2. Cependant, les colonnes T2_1H_R1/R2 et T3_1H_R1/R2 présentent un grand nombre de valeurs aberrantes (outliers), ce qui peut indiquer des réponses génétiques atypiques à 1 heure pour ces traitements.
Les intervalles interquartiles pour T1 sont beaucoup plus petits, suggérant que les données pour ce traitement sont plus concentrées autour de la médiane. 
Toutefois, T1 présente également de nombreux outliers, en plus grand nombre que pour T2 ou T3, ce qui peut indiquer des comportements génétiques spécifiques ou une variabilité accrue pour certains gènes sous ce traitement.

```{r echo=F}
#Pour installer les packages
if (!require("FactoMineR")) install.packages("FactoMineR")
if (!require("factoextra")) install.packages("factoextra")
if (!require("corrplot")) install.packages("corrplot")
library(FactoMineR)
library(factoextra)
library(corrplot)
# A présent, on passe sur l'ACP Centrée. Pour cela, on commence par centrer notre jeu de données.
#ACP Centrée réduite (Toutes les variables ont la même importance)
Tt_sH_Rr <- DataBio[c(1: 36)]
DataBioC <- scale(Tt_sH_Rr, center=TRUE, scale=T)

# On fait la transposée pour avoir : les Tt_sH_Rr décrits par les gènes (J'avour je suis pas sûr à 100% pour ce passage. Sinon on peut enlever la transposée)
ACP_DataBio_reduite <- PCA(DataBio[c(1:36)],  scale.unit = T, graph = F)
ACP_DataBio_reduite$eig
fviz_eig(ACP_DataBio_reduite,addlabels = TRUE, ylim = c(0, 100), main = "Valeurs propres")
# Projection des individus
fviz_pca_ind(ACP_DataBio_reduite, geom = c("point"),col.ind = "cos2", gradient.cols = c("blue", "red"), repel = TRUE, title = "Projection des individus (Tt_sH_Rr)")

```

Faites une classification non supervisée (clustering) de ces données afin de regrouper les Tt sH Rr.
en plusieurs classes homog`enes.
```{r,echo=T, error=F,warning=F,message=F}
if (!require("forcats")) install.packages("forcats")
if (!require("ggplot2")) install.packages("ggplot2")
if (!require("corrplot")) install.packages("corrplot")
if (!require("FactoMineR")) install.packages("FactoMineR")
if (!require("factoextra")) install.packages("factoextra")
if (!require("mclust")) install.packages("mclust")
if (!require("cluster")) install.packages("cluster")
if (!require("ppclust")) install.packages("ppclust")
if (!require("circlize")) install.packages("circlize")
if (!require("ggalluvial")) install.packages("ggalluvial")
library(forcats)
library(ggplot2)
library(corrplot)
library(reshape2)

library(FactoMineR)
library(factoextra)

library(mclust)
library(cluster)
library(ppclust)

library(circlize)
library(ggalluvial)

# Maintenant que l'ACP a été effectuée, on fait un clustering des classes à l'aide de la méthode K-means.

# Avant de débuter le clustering avec la méthode K-means, il faut déterminer le nombre de classes.

Kmax<-20
reskmeanscl<-matrix(0,nrow=nrow(DataBio),ncol=Kmax-1)
Iintra<-NULL
for (k in 1:Kmax){
  resaux<-kmeans(DataBioCR,centers=k)
  reskmeanscl[,k-1]<-resaux$cluster
  Iintra<-c(Iintra,resaux$tot.withinss) # tot.withinss correspond à la somme des composantes au carré des éléments du cluster par cluster
}

df<-data.frame(K=1:20,Iintra=Iintra)
ggplot(df,aes(x=K,y=Iintra))+
  geom_line()+
  geom_point()+
  xlab("Nombre de classes")+
  ylab("Inertie intraclasse")

# Avec cette méthode, on dirait que le coude correspond lorsque le nombre de classes est de 2.
# On va alors utiliser 2 classes pour la méthode des K-means.

reskmeans<-kmeans(DataBioCR,centers = 2)
fviz_cluster(reskmeans,data=Tt_sH_Rr,
             ellipse.type="norm",labelsize=8,
             geom=c("point"))+ggtitle("")
#fviz_pca_ind(resacp,col.ind=as.factor(reskmeans$cluster),geom = c("point"),axes=c(1,2))

# A présent, on va essayer une autre méthode, la méthode hiérarchique.

# D'une part, on fait le calcul de la matrice de distances
dist_matrix <- dist(DataBioCR, method = "euclidean")
# Clustering hiérarchique avec la méthode de liaison "ward.D2", on peut aussi faire avec "single", "complete","average" ...
hc <- hclust(dist_matrix, method = "ward.D2") 
# Afficher le dendrogramme
fviz_dend(hc,k=2,show_labels = FALSE,
rect = TRUE, rect_fill = TRUE,palette = "npg",
rect_border = "npg",
labels_track_height = 0.8)+ggtitle("")

# (Le temps de chargement est plutôt long, C'est NORMAL)

```

Préliminairement, construisez un jeu de données DataExpMoy contenant la moyenne des expressions sur les réplicats de chaque g`ene, pour chaque traitement et chaque heure. DataExpMoy est
donc une matrice de taille G × 18. Vous pourrez utiliser les variables ExpT1, ExpT2 et ExpT3
pour commenter vos résultats des questions suivantes.

Menez une analyse en composantes principales pour les gènes à partir du jeu de données DataExpMoy.

```{r echo=F}
# A présent,on va essayer de construire la matrice DataExpMoy. C'est une matrice de taille G * 18. Le nombre de lignes correspond aux gènes et les colonnes correspondent aux moyennes de T1,T2,T3 pour chaque heure. On a alors :
# colonne 1 : moyenne(T1_1H_R1/2)
# colonne 2 : moyenne(T1_2H_R1/2)
# colonne 3 : moyenne(T1_3H_R1/2)
# colonne 4 : moyenne(T1_4H_R1/2)
# colonne 5 : moyenne(T1_5H_R1/2)
# colonne 6 : moyenne(T1_6H_R1/2)
# colonne 7 : moyenne(T2_1H_R1/2)
# colonne 8 : moyenne(T2_2H_R1/2)
# ...
# colonne 18 : moyenne(T3_6H_R1/2)
# On essaye de créer cette matrice :
cols_T1_R1 <- grep("^T1_.*_R1$", colnames(DataBio))  # T1 pour R1
cols_T1_R2 <- grep("^T1_.*_R2$", colnames(DataBio))  # T1 pour R2

cols_T2_R1 <- grep("^T2_.*_R1$", colnames(DataBio))  # T2 pour R1
cols_T2_R2 <- grep("^T2_.*_R2$", colnames(DataBio))  # T2 pour R2

cols_T3_R1 <- grep("^T3_.*_R1$", colnames(DataBio))  # T3 pour R1
cols_T3_R2 <- grep("^T3_.*_R2$", colnames(DataBio))  # T3 pour R2

# Moyenne pour T1
T1_means <- (DataBio[, cols_T1_R1] + DataBio[, cols_T1_R2]) / 2

# Moyenne pour T2
T2_means <- (DataBio[, cols_T2_R1] + DataBio[, cols_T2_R2]) / 2

# Moyenne pour T3
T3_means <- (DataBio[, cols_T3_R1] + DataBio[, cols_T3_R2]) / 2

MatriceDataExpMoy <- cbind(T1_means, T2_means, T3_means)
DataExpMoy <- as.data.frame(cbind(T1_means, T2_means, T3_means))

# Pour vérifier la taille
dim(DataExpMoy)  # Devrait être 542 × 18 (c'est bon)

# On utilise T1 /T2 /T3 pour Identifier les gènes particulièrement influents pour un traitement spécifique.
# Ajouter les colonnes ExpT1, ExpT2, ExpT3 pour un filtrage
DataExpMoy_full <- cbind(MatriceDataExpMoy, ExpT1 = DataBio$ExpT1, ExpT2 = DataBio$ExpT2, ExpT3 = DataBio$ExpT3)

# Moyenne des gènes surexprimés pour T1 à 6 heures
mean_sur_T1_6H <- mean(DataExpMoy_full[DataExpMoy_full$ExpT1 == "Sur", "T1_6H"])
print(mean_sur_T1_6H)
# On fait la ACP de ce nouveau jeu de données

DataExpMoyC <- scale(t(DataExpMoy), center=TRUE)
# On fait la transposée pour avoir : les Tt_sH_Rr décrits par les gènes (J'avour je suis pas sûr à 100% pour ce passage. Sinon on peut enlever la transposée)
ACP_DataExpMoy_reduite <- PCA(DataExpMoyC,  scale.unit = T, graph = F)
ACP_DataExpMoy_reduite$eig
fviz_eig(ACP_DataExpMoy_reduite,addlabels = TRUE, ylim = c(0, 100), main = "Valeurs propres")
# Projection des DataExpMoy
fviz_pca_ind(ACP_DataExpMoy_reduite, geom = c("point"),col.ind = "cos2", gradient.cols = c("blue", "red"), repel = TRUE, title = "Projection des DataExpMoy")

```

Faites une classification non supervisée (clustering) des gènes à partir de leur expression (DataExpMoy) afin d’obtenir des classes de gènes homogènes (ayant la même évolution d’expression).

```{r,echo=T, error=F,warning=F,message=F}
if (!require("forcats")) install.packages("forcats")
if (!require("ggplot2")) install.packages("ggplot2")
if (!require("corrplot")) install.packages("corrplot")
if (!require("FactoMineR")) install.packages("FactoMineR")
if (!require("factoextra")) install.packages("factoextra")
if (!require("mclust")) install.packages("mclust")
if (!require("cluster")) install.packages("cluster")
if (!require("ppclust")) install.packages("ppclust")
if (!require("circlize")) install.packages("circlize")
if (!require("ggalluvial")) install.packages("ggalluvial")
library(forcats)
library(ggplot2)
library(corrplot)
library(reshape2)

library(FactoMineR)
library(factoextra)

library(mclust)
library(cluster)
library(ppclust)

library(circlize)
library(ggalluvial)

# Maintenant que l'ACP a été effectuée, on fait un clustering des classes à l'aide de la méthode K-means.

# Avant de débuter le clustering avec la méthode K-means, il faut déterminer le nombre de classes.

Kmax<-15
reskmeanscl<-matrix(0,nrow=nrow(DataExpMoyCR),ncol=Kmax-1)
Iintra<-NULL
for (k in 1:Kmax){
  resaux<-kmeans(DataExpMoyCR,centers=k)
  reskmeanscl[,k-1]<-resaux$cluster
  Iintra<-c(Iintra,resaux$tot.withinss) # tot.withinss correspond à la somme des composantes au carré des éléments du cluster par cluster
}

df<-data.frame(K=1:15,Iintra=Iintra)
ggplot(df,aes(x=K,y=Iintra))+
  geom_line()+
  geom_point()+
  xlab("Nombre de classes")+
  ylab("Inertie intraclasse")

# Avec cette méthode, on dirait que le coude correspond lorsque le nombre de classes est de 2.
# On va alors utiliser 2 classes pour la méthode des K-means.

ExpMoykmeans<-kmeans(DataExpMoyCR,centers = 2)
fviz_cluster(ExpMoykmeans,data=DataExpMoyCR,ellipse.type="norm",labelsize=8,geom=c("point"))+ggtitle("")
#fviz_pca_ind(resacp,col.ind=as.factor(ExpMoykmean$cluster),geom = c("point"),axes=c(1,2))

# A présent, on va essayer une autre méthode, la méthode hiérarchique.

# D'une part, on fait le calcul de la matrice de distances
dist_matrix_ExpMoy <- dist(DataExpMoyCR, method = "euclidean")
# Clustering hiérarchique avec la méthode de liaison "ward.D2", on peut aussi faire avec "single", "complete","average" ...
hc_ExpMoy <- hclust(dist_matrix_ExpMoy, method = "ward.D2") 
# Afficher le dendrogramme
fviz_dend(hc_ExpMoy,k=2,show_labels = FALSE,
rect = TRUE, rect_fill = TRUE,palette = "npg",
rect_border = "npg",
labels_track_height = 0.8)+ggtitle("")
# (Le temps de chargement est plutôt long)

```
Faites une classification non supervisée (clustering) des gènes à partir des variables ExpT1, ExpT2 et ExpT3. Comparez avec les résultats de la question précédente.


